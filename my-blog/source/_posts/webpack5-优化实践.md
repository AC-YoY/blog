---
title: webpack5 优化实践
date: 2020-12-04 02:18:30
tags:
- webpack
- 打包
---

## 前言
当我们在聊打包优化的时候，我们到底要讨论什么？更短的构建时间？更快的页面访问速度？加速热更新带来的丝滑开发体验？打包是一件有所取舍的事，先明确你的目的，才会做出合适的选择

本文仅取得了如下成果，如果这不是你的目的，终止阅读，做些更有价值的事去

   - 生产以外的环境，打包速度 2 倍以上提升
   - 针对开发环境再次构建的场景，打包速度将近10倍提升，（代价是热更新变慢）

## 常见的 webpack 打包过程分析工具
这是几个常见的分析工具，可以帮助你去分析自己的构建


1. 完整分析整个打包流程

在 script 下添加如下参数，--profile --json > stats.json，会生成一份分析文件，这是最完整的方案。但是需要对 webpack 本身有深度了解

2. 分析包之间的大小和包之间的依赖关系

webpack-bundle-analyzer，这是目前使用过唯一个还能在 webpack5 下工作的分析相关插件

3. 分析打包速度

speed-measure-webpack-plugin，这个插件可以分析每个 loader / plugin 打包所占用的时间。但是目前不支持 webpack5



## 优化尝试
非常遗憾的是，本次优化，大部分分析工具均不能在 5 下运行；stats.json 文件太过于复杂，看起来无从下手；仅有 webpack-bundle-analyzer，帮助我们分析出了部分重复的包；所以整个过程主要依靠的还是**猜测 + 尝试**

### 几个比较耗时的构建步骤
sourcemap, uglify，eslint-loader，vue-loader，基本上耗时从大到小排列，这几个是对构建影响比较大的点，下面说说做的具体优化


### 分场景移除构建步骤
不用说，如果移除耗时步骤，肯定效果巨大，那是否是每个环境都需要这些步骤呢？考量之后移除了这些

| **环境** | **构建步骤** | **分析** | 效果 |
| ---- | ---- | ---- | ---- |
| 生产 | sourcemap | 原本配合sentry分析线上问题，实际上目前没有任何场景在使用 | 非常显著 |
| 测试 | sourcemap | 用的很少，改成 cheap-source-map | 非常显著 |
| 测试 | uglify | 测试环境去做 uglify 几乎无意义 | 非常显著 |



### 缓存
除了干掉构建步骤以外，这是真正能明显看到效果的方案；具体思路就是将一些模块的转换之后的结果缓存下来，当下次构建时，无需重复构建
在 webpack 4 下：

- hard-source-webpack-plugin，简单好用，效果明显，推荐
- 也可以单独使用 vue-loader + cache-loader & babel-loader 单独配置缓存的方案，效果明显

在 webpack 5 下：

- 使用内置 cache 模块，默认 cache 在 development 模式下是存放在内存中，如果显式配置成 filesystem，将会将中间过程的打包结果存放在 node_modules/.cache/webpack 文件夹下。这个模式**提速极大**，例如在我的机器上，第二次构建开发任务，原先 40s 的打包只需要 4s，但是代价是热更新速度明显从 2~3s 变到 5～10s。可能更加适合多条分支修正 bug 的场景



### 压榨电脑来提升构建速度

- 多线程，单独使用 thread-loader 或者某些 loader / plugin 可以配置多线程
- parallel，并行计算，和上面一个类似，一般配置在具体的某个 loader / plugin 上

 结论，几乎没有差异，可能是大部分内置配置已经非常合理。当尝试配置 worker 数量到本机器 cpu 物理上限时（一般是 os.cpus() - 1），反而还会降低速度，可能是任务无法拆分更细以及 ipc 成本过高，细节不可考


### 拆包方案及其他

- splitChunks：无明显差异，当配置 chunk: all 时热更新有些微提升（默认是 async，仅会拆分异步模块）
- runtimeChunk: 无明显差异
- dllPlugin: 无明显差异，且配置复杂，自动引入插件在 webpack5 下失败，不建议
- externals: 无明显差异，使用 cdn 引入了 vue 文件，收益不明显
- resolve相关: 无明显差异，虽然说查找/分析模块是打包的核心过程之一，但是实际看到的差异大概是（400ms / 40s）



## 总结
构建是个非常有意思的话题，本文说了和构建速度相关的一点尝试，也取得了一些激动人心的变化，但在B端的核心场景上（热更新加速），并没有任何亮眼之处。
个人觉得后续可以聊的几个方向有：

- 场景再细分，例如提供不同的开发模式命令
- 深入研究热更新原理 + 模块标记方案 + cache配置，配置出更加精准的缓存方案
- B端应该支持什么版本的浏览器？
- babel 实际支持哪些语法？推荐使用哪些？
